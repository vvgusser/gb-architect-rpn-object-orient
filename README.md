## RPN Evaluator

Программа для вычисления инфиксных выражений с помощью алгоритмов токенизации, конвертирования в ОПН и вычисления ОПН.

## Стек

- Java 17 скачать можно [тут](https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html)
- Apache Maven (в репозитории есть Maven Wrapper так что устанавливать не придется)

## Запуск

Для начала необходимо скомпилировать приложение, для этого в консоле пишем

```text
./mvnw clean package
```

Эта команда соберет нам исполняемый jar файл и во время сборки еще прогонит все тесты. Если тесты не пройдут, сборка упадет.

После сборки у появится папка `target`, в ней и будет находиться собранный артефакт. Для запуска приложения нужно выполнить следующую команду

```text
java -jar target/infix-evaluator.jar
```

После этого запустится REPL интерфейс в котором можно вычислять выражения.

## Решения

### Токенизация

Вводимое инфиксное выражение токенизируется перед тем как вычисляться. Используется классический алгоритм с двумя буферами. В реализации этого
интерпретатора он упрощен и буфер используется только для чисел. Процесс токенизации разбит на несколько шагов

#### Шаг валидации

После первичной токенизации, лексер запускает правила валидации на токенах, правил валидации может быть много. Ниже перечислены те, что
реализованы в этом интерпретаторе.

- Количество открывающих скобок совпадает с количеством закрывающих
- Числа не разделяются пробелами
- Формат чисел корректный
- Выражение начинается с унарного оператора, числа или скобки
- Выражение не заканчивается оператором
- Перед открывающей скобкой всегда есть оператор, исключение - начало выражения
- Нет последовательностей операторов, например `+++`, если идут два подряд оператора, второй должен быть унарным, а за ним число
- Перед закрывающей скобкой всегда должно быть число, либо другая закрывающая скобка

#### Шаг сжатия токенов

После шага валидации, токенизатор сжимает некоторые токены. В нашем случае это унарные операторы и справа стоящие числа. Пример выражения:

```text
2 + -3
```

Первично, такое выражение разбивается на такие токены

```text
[
  {value: 2, type: number, pos: 0},
  {value: +, type: operator, pos: 2},
  {value: -, type: operator, pos: 4},
  {value: 3, type: number, pos: 5}
]
```

Дальше прогоняется валидация. И после этого, токены сжимаются и преобретают следующую форму

```text
[
  {value: 2, type: number, pos: 0},
  {value: +, type: operator, pos: 2},
  {value: -3, type: number, pos: 4}
]
```

Токены можно сжимать и сразу, при первичной токенизации, но я разделил этот процесс чтобы открыть больше возможностей для правил валидации.

### Вычисление

Есть интерфейс для evaluator'ов, каждый evaluator получает на вход выражение, которое должен разбить на токены с помощью нужного лексера и
вычислить его. В интерпретаторе есть RpnEvaluator, который работает с InfixLexer, после токенизации, RpnEvaluator переставляет токены в infix
порядке в ОПН порядок с помощью алгоритм shunting yard. После чего классическим алгоритмом вычисления ОПН на стеке вычисляет полученные токены.

### Примеры

```text
>>> 9 + 9
> 9 9 +
> 18

>>>
Empty expressions are not allowed

>>> (1 + 2) * 4 + 3
> 1 2 + 4 * 3 +
> 15

>>> --0
--0
^
error: There can only be an open parenthesis or a number after the unary operator

>>> *98
*98
^
error: An expression can only start with a unary operator

>>> /32
/32
^
error: An expression can only start with a unary operator

>>> 0*()
0*()
   ^
error: There can only be a number or another closing parenthesis before the closing parenthesis

>>> 0*(9 - 2 -)
0*(9 - 2 -)
          ^
error: There can only be a number or another closing parenthesis before the closing parenthesis

>>> 125. + 125.
125. + 125.
^
error: Invalid number, only integers and fractional numbers are allowed, there must be numbers after the period in the fractional

>>> 398 * 0 -
398 * 0 -
        ^
error: Expression cannot end with operator

>>> 122 / 0
Division by zero

>>> 122 / (98 - 98)
Division by zero

>>> 916 000 + 843
916 000 + 843
    ^
error: Numbers cannot be separated by spaces
```

